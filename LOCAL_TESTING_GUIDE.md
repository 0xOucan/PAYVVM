# Local Testing Guide - PAYVVM Explorer

## Prerequisites Checklist

Before starting local testing, ensure you have:

- [x] Node.js >= 20.18.3
- [x] Yarn package manager
- [x] pnpm (for Envio package)
- [x] Alchemy API key (free tier works)
- [x] Understanding that PAYVVM contracts **don't emit events**

## Step 1: Environment Setup

### 1.1 Create Alchemy Account

1. Go to [https://www.alchemy.com/](https://www.alchemy.com/)
2. Sign up for free account
3. Create new app:
   - Name: "PAYVVM Explorer"
   - Chain: Ethereum
   - Network: Sepolia testnet
4. Copy your API key

### 1.2 Configure Environment Variables

```bash
cd /home/oucan/PayVVM/envioftpayvvm/packages/envio

# Create .env file
cat > .env << 'EOF'
# Alchemy API Key for Ethereum Sepolia
ALCHEMY_API_KEY=your_alchemy_api_key_here

# Database (auto-generated by Envio)
DATABASE_URL=postgresql://postgres:testing@localhost:5432/envio-dev

# Optional: Custom RPC
# CUSTOM_RPC_URL=https://sepolia.infura.io/v3/YOUR_KEY
EOF
```

Replace `your_alchemy_api_key_here` with your actual API key.

### 1.3 Install Dependencies

```bash
# From envioftpayvvm root
cd /home/oucan/PayVVM/envioftpayvvm

# Install all dependencies
yarn install

# Install Envio package dependencies
cd packages/envio
pnpm install
```

## Step 2: Test Current Configuration

### 2.1 Try Envio Codegen

```bash
cd /home/oucan/PayVVM/envioftpayvvm/packages/envio

# Attempt to generate types
pnpm codegen
```

**Expected Outcomes:**

#### If Successful âœ…
```
âœ“ Generated TypeScript types
âœ“ Created handler templates
âœ“ Database schema ready
```
â†’ Continue to Step 3

#### If Failed âŒ
```
Error: Function-based indexing not supported
```
â†’ Jump to Alternative Approach (Step 4)

## Step 3: Run Envio Indexer (If Codegen Worked)

### 3.1 Start Development Mode

```bash
cd packages/envio

# Start indexer in dev mode
pnpm dev
```

You should see:
```
ðŸš€ Starting Envio indexer...
ðŸ“¡ Connected to Sepolia RPC
ðŸ“Š Syncing from block 7340000
â³ Indexing transactions...
```

### 3.2 Check GraphQL Endpoint

Open browser to: `http://localhost:8080/graphql`

Try a test query:
```graphql
{
  transactions(limit: 5) {
    id
    from
    to
    timestamp
  }
}
```

### 3.3 Start Frontend

In another terminal:
```bash
cd /home/oucan/PayVVM/envioftpayvvm
yarn start
```

Visit: `http://localhost:3000`

## Step 4: Alternative Approach (If Envio Doesn't Support Functions)

Since PAYVVM contracts don't emit events, we'll build a custom indexer.

### 4.1 Option A: Simple Transaction Tracker

Create `packages/custom-indexer/` with basic transaction tracking:

```bash
cd /home/oucan/PayVVM/envioftpayvvm/packages
mkdir custom-indexer
cd custom-indexer

# Initialize Node.js project
npm init -y

# Install dependencies
npm install ethers@6 @apollo/server graphql express dotenv
npm install -D typescript @types/node tsx

# Create TypeScript config
npx tsc --init
```

Create `src/index.ts`:
```typescript
import { ethers } from 'ethers';
import dotenv from 'dotenv';

dotenv.config();

const EVVM_ADDRESS = '0x9486f6C9d28ECdd95aba5bfa6188Bbc104d89C3e';
const RPC_URL = `https://eth-sepolia.g.alchemy.com/v2/${process.env.ALCHEMY_API_KEY}`;

const provider = new ethers.JsonRpcProvider(RPC_URL);

// ABI for the functions we want to track
const evvmInterface = new ethers.Interface([
  'function pay(address,address,string,address,uint256,uint256,uint256,bool,address,bytes)',
  'function payMultiple((address,address,string,address,uint256,uint256,uint256,bool,address,bytes)[])',
  // Add more functions...
]);

async function indexBlock(blockNumber: number) {
  console.log(`Indexing block ${blockNumber}...`);

  const block = await provider.getBlock(blockNumber, true);
  if (!block) return;

  for (const txHash of block.transactions) {
    const tx = await provider.getTransaction(txHash);
    if (!tx || tx.to?.toLowerCase() !== EVVM_ADDRESS.toLowerCase()) continue;

    try {
      const decoded = evvmInterface.parseTransaction({
        data: tx.data,
        value: tx.value
      });

      console.log(`Found ${decoded.name} transaction:`);
      console.log(`  From: ${tx.from}`);
      console.log(`  Hash: ${tx.hash}`);
      console.log(`  Args:`, decoded.args);

      // TODO: Store in database
    } catch (e) {
      // Unknown function
    }
  }
}

// Start indexing
async function main() {
  const latestBlock = await provider.getBlockNumber();
  console.log(`Latest block: ${latestBlock}`);
  console.log(`Starting from block 7340000...`);

  for (let block = 7340000; block <= latestBlock; block++) {
    await indexBlock(block);
  }

  // Listen for new blocks
  provider.on('block', indexBlock);
}

main().catch(console.error);
```

Run it:
```bash
npx tsx src/index.ts
```

### 4.2 Option B: Use The Graph Protocol

The Graph supports tracking transactions even without events.

1. Install Graph CLI:
```bash
npm install -g @graphprotocol/graph-cli
```

2. Initialize Graph project:
```bash
graph init --product subgraph-studio payvvm-explorer
```

3. Update `subgraph.yaml` to track call handlers instead of events

4. Deploy to The Graph Studio

### 4.3 Option C: Direct State Polling

Create a simple API that polls contract state:

```typescript
import { ethers } from 'ethers';

const evvmContract = new ethers.Contract(
  '0x9486f6C9d28ECdd95aba5bfa6188Bbc104d89C3e',
  [
    'function getBalance(address,address) view returns (uint256)',
    'function isAddressStaker(address) view returns (bool)',
    'function getNextCurrentSyncNonce(address) view returns (uint256)',
  ],
  provider
);

// Poll balances
async function getAccountInfo(address: string) {
  const mateBalance = await evvmContract.getBalance(
    address,
    '0x0000000000000000000000000000000000000001' // MATE token
  );

  const isStaker = await evvmContract.isAddressStaker(address);
  const nonce = await evvmContract.getNextCurrentSyncNonce(address);

  return { mateBalance, isStaker, nonce };
}
```

## Step 5: Frontend Development (Works Regardless)

The frontend can work with any backend approach:

### 5.1 Direct RPC Calls

```typescript
// packages/nextjs/hooks/useEvvmBalance.ts
import { useContractRead } from 'wagmi';

export function useEvvmBalance(address: string, token: string) {
  return useContractRead({
    address: '0x9486f6C9d28ECdd95aba5bfa6188Bbc104d89C3e',
    abi: [
      {
        name: 'getBalance',
        type: 'function',
        stateMutability: 'view',
        inputs: [
          { name: 'user', type: 'address' },
          { name: 'token', type: 'address' }
        ],
        outputs: [{ type: 'uint256' }]
      }
    ],
    functionName: 'getBalance',
    args: [address, token],
  });
}
```

### 5.2 Use GraphQL (If Indexer Works)

```typescript
import { useQuery, gql } from '@apollo/client';

const GET_TRANSACTIONS = gql`
  query GetTransactions($address: String!) {
    transactions(where: { from: $address }) {
      id
      to
      amount
      timestamp
    }
  }
}`;

export function useTransactions(address: string) {
  return useQuery(GET_TRANSACTIONS, {
    variables: { address }
  });
}
```

## Step 6: Test with Real Data

### 6.1 Check Deployed Contracts on Etherscan

Visit each contract and check "Transactions" tab:

- [EVVM Transactions](https://sepolia.etherscan.io/address/0x9486f6C9d28ECdd95aba5bfa6188Bbc104d89C3e#internaltx)
- [Staking Transactions](https://sepolia.etherscan.io/address/0x64A47d84dE05B9Efda4F63Fbca2Fc8cEb96E6816#internaltx)
- [NameService Transactions](https://sepolia.etherscan.io/address/0xa4ba4e9270bde8fbbf4328925959287a72ba0a55#internaltx)

### 6.2 Test State Reading

```bash
# Use cast to test contract reads
cast call 0x9486f6C9d28ECdd95aba5bfa6188Bbc104d89C3e \
  "getBalance(address,address)(uint256)" \
  "0xYourAddress" \
  "0x0000000000000000000000000000000000000001" \
  --rpc-url https://eth-sepolia.g.alchemy.com/v2/YOUR_KEY
```

### 6.3 Inspect Existing Implementation

The EVVM team has a working frontend at https://evvm.dev/

Inspect their network calls to see how they:
- Read contract state
- Display balances
- Show transactions

## Troubleshooting

### "Envio codegen fails"
â†’ Envio likely doesn't support function-based indexing
â†’ Use Alternative Approach (Step 4)

### "No transactions found"
â†’ Check start_block in config
â†’ Verify contracts have been used on Sepolia
â†’ Try querying Etherscan directly

### "RPC rate limited"
â†’ Upgrade Alchemy plan
â†’ Add retry logic with exponential backoff
â†’ Use multiple RPC providers

### "Can't read contract state"
â†’ Verify RPC URL is correct
â†’ Check contract addresses
â†’ Ensure ABIs match deployed contracts

## Next Steps After Local Testing

Once local testing works:

1. âœ… Document which approach worked
2. âœ… Optimize indexing performance
3. âœ… Add caching layer
4. âœ… Build frontend components
5. âœ… Deploy indexer to production
6. âœ… Deploy frontend to Vercel

## Resources

- EVVM Live Frontend: https://evvm.dev/
- Etherscan Sepolia: https://sepolia.etherscan.io/
- Alchemy Dashboard: https://dashboard.alchemy.com/
- The Graph Docs: https://thegraph.com/docs/
- Wagmi Docs: https://wagmi.sh/

---

**Important**: The key insight is that PAYVVM contracts **don't emit events**, so traditional event-based indexing won't work. We need transaction-based or state-polling approaches instead.
