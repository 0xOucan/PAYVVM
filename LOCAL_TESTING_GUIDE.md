# Local Testing Guide - PAYVVM Explorer

## Prerequisites Checklist

Before starting local testing, ensure you have:

- [x] Node.js >= 20.18.3
- [x] Yarn package manager
- [x] pnpm (for Envio package)
- [x] Alchemy API key (free tier works)
- [x] Understanding that PAYVVM contracts **don't emit events**

## Step 1: Environment Setup

### 1.1 Create Alchemy Account

1. Go to [https://www.alchemy.com/](https://www.alchemy.com/)
2. Sign up for free account
3. Create new app:
   - Name: "PAYVVM Explorer"
   - Chain: Ethereum
   - Network: Sepolia testnet
4. Copy your API key

### 1.2 Configure Environment Variables

```bash
cd /home/oucan/PayVVM/envioftpayvvm/packages/envio

# Create .env file
cat > .env << 'EOF'
# Alchemy API Key for Ethereum Sepolia
ALCHEMY_API_KEY=your_alchemy_api_key_here

# Database (auto-generated by Envio)
DATABASE_URL=postgresql://postgres:testing@localhost:5432/envio-dev

# Optional: Custom RPC
# CUSTOM_RPC_URL=https://sepolia.infura.io/v3/YOUR_KEY
EOF
```

Replace `your_alchemy_api_key_here` with your actual API key.

### 1.3 Install Dependencies

```bash
# From envioftpayvvm root
cd /home/oucan/PayVVM/envioftpayvvm

# Install all dependencies
yarn install

# Install Envio package dependencies
cd packages/envio
pnpm install
```

## Step 2: Test Current Configuration

### 2.1 Try Envio Codegen

```bash
cd /home/oucan/PayVVM/envioftpayvvm/packages/envio

# Attempt to generate types
pnpm codegen
```

**Expected Outcomes:**

#### If Successful ✅
```
✓ Generated TypeScript types
✓ Created handler templates
✓ Database schema ready
```
→ Continue to Step 3

#### If Failed ❌
```
Error: Function-based indexing not supported
```
→ Jump to Alternative Approach (Step 4)

## Step 3: Run Envio Indexer (If Codegen Worked)

### 3.1 Start Development Mode

```bash
cd packages/envio

# Start indexer in dev mode
pnpm dev
```

You should see:
```
🚀 Starting Envio indexer...
📡 Connected to Sepolia RPC
📊 Syncing from block 7340000
⏳ Indexing transactions...
```

### 3.2 Check GraphQL Endpoint

Open browser to: `http://localhost:8080/graphql`

Try a test query:
```graphql
{
  transactions(limit: 5) {
    id
    from
    to
    timestamp
  }
}
```

### 3.3 Start Frontend

In another terminal:
```bash
cd /home/oucan/PayVVM/envioftpayvvm
yarn start
```

Visit: `http://localhost:3000`

## Step 4: Alternative Approach (If Envio Doesn't Support Functions)

Since PAYVVM contracts don't emit events, we'll build a custom indexer.

### 4.1 Option A: Simple Transaction Tracker

Create `packages/custom-indexer/` with basic transaction tracking:

```bash
cd /home/oucan/PayVVM/envioftpayvvm/packages
mkdir custom-indexer
cd custom-indexer

# Initialize Node.js project
npm init -y

# Install dependencies
npm install ethers@6 @apollo/server graphql express dotenv
npm install -D typescript @types/node tsx

# Create TypeScript config
npx tsc --init
```

Create `src/index.ts`:
```typescript
import { ethers } from 'ethers';
import dotenv from 'dotenv';

dotenv.config();

const EVVM_ADDRESS = '0x9486f6C9d28ECdd95aba5bfa6188Bbc104d89C3e';
const RPC_URL = `https://eth-sepolia.g.alchemy.com/v2/${process.env.ALCHEMY_API_KEY}`;

const provider = new ethers.JsonRpcProvider(RPC_URL);

// ABI for the functions we want to track
const evvmInterface = new ethers.Interface([
  'function pay(address,address,string,address,uint256,uint256,uint256,bool,address,bytes)',
  'function payMultiple((address,address,string,address,uint256,uint256,uint256,bool,address,bytes)[])',
  // Add more functions...
]);

async function indexBlock(blockNumber: number) {
  console.log(`Indexing block ${blockNumber}...`);

  const block = await provider.getBlock(blockNumber, true);
  if (!block) return;

  for (const txHash of block.transactions) {
    const tx = await provider.getTransaction(txHash);
    if (!tx || tx.to?.toLowerCase() !== EVVM_ADDRESS.toLowerCase()) continue;

    try {
      const decoded = evvmInterface.parseTransaction({
        data: tx.data,
        value: tx.value
      });

      console.log(`Found ${decoded.name} transaction:`);
      console.log(`  From: ${tx.from}`);
      console.log(`  Hash: ${tx.hash}`);
      console.log(`  Args:`, decoded.args);

      // TODO: Store in database
    } catch (e) {
      // Unknown function
    }
  }
}

// Start indexing
async function main() {
  const latestBlock = await provider.getBlockNumber();
  console.log(`Latest block: ${latestBlock}`);
  console.log(`Starting from block 7340000...`);

  for (let block = 7340000; block <= latestBlock; block++) {
    await indexBlock(block);
  }

  // Listen for new blocks
  provider.on('block', indexBlock);
}

main().catch(console.error);
```

Run it:
```bash
npx tsx src/index.ts
```

### 4.2 Option B: Use The Graph Protocol

The Graph supports tracking transactions even without events.

1. Install Graph CLI:
```bash
npm install -g @graphprotocol/graph-cli
```

2. Initialize Graph project:
```bash
graph init --product subgraph-studio payvvm-explorer
```

3. Update `subgraph.yaml` to track call handlers instead of events

4. Deploy to The Graph Studio

### 4.3 Option C: Direct State Polling

Create a simple API that polls contract state:

```typescript
import { ethers } from 'ethers';

const evvmContract = new ethers.Contract(
  '0x9486f6C9d28ECdd95aba5bfa6188Bbc104d89C3e',
  [
    'function getBalance(address,address) view returns (uint256)',
    'function isAddressStaker(address) view returns (bool)',
    'function getNextCurrentSyncNonce(address) view returns (uint256)',
  ],
  provider
);

// Poll balances
async function getAccountInfo(address: string) {
  const mateBalance = await evvmContract.getBalance(
    address,
    '0x0000000000000000000000000000000000000001' // MATE token
  );

  const isStaker = await evvmContract.isAddressStaker(address);
  const nonce = await evvmContract.getNextCurrentSyncNonce(address);

  return { mateBalance, isStaker, nonce };
}
```

## Step 5: Frontend Development (Works Regardless)

The frontend can work with any backend approach:

### 5.1 Direct RPC Calls

```typescript
// packages/nextjs/hooks/useEvvmBalance.ts
import { useContractRead } from 'wagmi';

export function useEvvmBalance(address: string, token: string) {
  return useContractRead({
    address: '0x9486f6C9d28ECdd95aba5bfa6188Bbc104d89C3e',
    abi: [
      {
        name: 'getBalance',
        type: 'function',
        stateMutability: 'view',
        inputs: [
          { name: 'user', type: 'address' },
          { name: 'token', type: 'address' }
        ],
        outputs: [{ type: 'uint256' }]
      }
    ],
    functionName: 'getBalance',
    args: [address, token],
  });
}
```

### 5.2 Use GraphQL (If Indexer Works)

```typescript
import { useQuery, gql } from '@apollo/client';

const GET_TRANSACTIONS = gql`
  query GetTransactions($address: String!) {
    transactions(where: { from: $address }) {
      id
      to
      amount
      timestamp
    }
  }
}`;

export function useTransactions(address: string) {
  return useQuery(GET_TRANSACTIONS, {
    variables: { address }
  });
}
```

## Step 6: Test with Real Data

### 6.1 Check Deployed Contracts on Etherscan

Visit each contract and check "Transactions" tab:

- [EVVM Transactions](https://sepolia.etherscan.io/address/0x9486f6C9d28ECdd95aba5bfa6188Bbc104d89C3e#internaltx)
- [Staking Transactions](https://sepolia.etherscan.io/address/0x64A47d84dE05B9Efda4F63Fbca2Fc8cEb96E6816#internaltx)
- [NameService Transactions](https://sepolia.etherscan.io/address/0xa4ba4e9270bde8fbbf4328925959287a72ba0a55#internaltx)

### 6.2 Test State Reading

```bash
# Use cast to test contract reads
cast call 0x9486f6C9d28ECdd95aba5bfa6188Bbc104d89C3e \
  "getBalance(address,address)(uint256)" \
  "0xYourAddress" \
  "0x0000000000000000000000000000000000000001" \
  --rpc-url https://eth-sepolia.g.alchemy.com/v2/YOUR_KEY
```

### 6.3 Inspect Existing Implementation

The EVVM team has a working frontend at https://evvm.dev/

Inspect their network calls to see how they:
- Read contract state
- Display balances
- Show transactions

## Troubleshooting

### "Envio codegen fails"
→ Envio likely doesn't support function-based indexing
→ Use Alternative Approach (Step 4)

### "No transactions found"
→ Check start_block in config
→ Verify contracts have been used on Sepolia
→ Try querying Etherscan directly

### "RPC rate limited"
→ Upgrade Alchemy plan
→ Add retry logic with exponential backoff
→ Use multiple RPC providers

### "Can't read contract state"
→ Verify RPC URL is correct
→ Check contract addresses
→ Ensure ABIs match deployed contracts

## Next Steps After Local Testing

Once local testing works:

1. ✅ Document which approach worked
2. ✅ Optimize indexing performance
3. ✅ Add caching layer
4. ✅ Build frontend components
5. ✅ Deploy indexer to production
6. ✅ Deploy frontend to Vercel

## Resources

- EVVM Live Frontend: https://evvm.dev/
- Etherscan Sepolia: https://sepolia.etherscan.io/
- Alchemy Dashboard: https://dashboard.alchemy.com/
- The Graph Docs: https://thegraph.com/docs/
- Wagmi Docs: https://wagmi.sh/

---

**Important**: The key insight is that PAYVVM contracts **don't emit events**, so traditional event-based indexing won't work. We need transaction-based or state-polling approaches instead.
